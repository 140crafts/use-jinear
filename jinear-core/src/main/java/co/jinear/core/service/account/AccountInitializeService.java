package co.jinear.core.service.account;

import co.jinear.core.exception.BusinessException;
import co.jinear.core.model.dto.account.AccountDto;
import co.jinear.core.model.entity.account.Account;
import co.jinear.core.model.enumtype.account.RoleType;
import co.jinear.core.model.enumtype.localestring.LocaleType;
import co.jinear.core.model.enumtype.team.TeamJoinType;
import co.jinear.core.model.enumtype.team.TeamVisibilityType;
import co.jinear.core.model.enumtype.username.UsernameRelatedObjectType;
import co.jinear.core.model.vo.account.AccountInitializeVo;
import co.jinear.core.model.vo.account.password.AccountPasswordVo;
import co.jinear.core.model.vo.team.TeamInitializeVo;
import co.jinear.core.model.vo.username.InitializeUsernameVo;
import co.jinear.core.repository.AccountRepository;
import co.jinear.core.service.team.TeamInitializeService;
import co.jinear.core.service.username.UsernameService;
import co.jinear.core.system.NormalizeHelper;
import co.jinear.core.system.RandomHelper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.util.Objects;
import java.util.Optional;

@Slf4j
@Service
@RequiredArgsConstructor
public class AccountInitializeService {
    private static final String TEAM_HANDLE_PREFIX = "team-";

    private final AccountRetrieveService accountRetrieveService;
    private final AccountRoleService accountRoleService;
    private final UsernameService usernameService;
    private final AccountPasswordService accountPasswordService;
    private final AccountRepository accountRepository;
    private final AccountMailConfirmationService accountMailConfirmationService;
    private final TeamInitializeService teamInitializeService;
    private final ModelMapper modelMapper;

    @Transactional
    public AccountDto initializeAccount(AccountInitializeVo accountInitializeVo) {
        log.info("Account initialize has started. accountInitializeVo: {}", accountInitializeVo);
        validateEmail(accountInitializeVo);
        Account account = createAccount(accountInitializeVo);
        assignUserRole(account);
        initializeUsername(account);
        initializeAccountPassword(account, accountInitializeVo);
        initializeTeam(account);
        sendMailConfirmationMail(account, accountInitializeVo);
        log.info("Account initialize has ended.");
        return modelMapper.map(account, AccountDto.class);
    }

    private Account createAccount(AccountInitializeVo accountInitializeVo) {
        log.info("Account create has started.");
        Account account = new Account();
        account.setEmail(accountInitializeVo.getEmail());
        account.setEmailConfirmed(accountInitializeVo.getEmailConfirmed());
        Account saved = accountRepository.save(account);
        log.info("Account create has finished. accountId: {}", saved.getAccountId());
        return saved;
    }

    private void validateEmail(AccountInitializeVo accountInitializeVo) {
        if (Objects.isNull(accountInitializeVo.getEmail())) {
            throw new BusinessException();
        }
        validateEmailIsNotUsed(accountInitializeVo.getEmail());
    }

    private void validateEmailIsNotUsed(String email) {
        accountRetrieveService.retrieveByEmail(email)
                .ifPresent(accountDto -> {
                    throw new BusinessException("account.email-in-use");
                });
    }

    private void assignUserRole(Account account) {
        accountRoleService.assignRoleToAccount(account.getAccountId(), RoleType.USER);
    }

    private void initializeAccountPassword(Account account, AccountInitializeVo accountInitializeVo) {
        String password = Optional.of(accountInitializeVo)
                .map(AccountInitializeVo::getPassword)
                .orElse(NormalizeHelper.normalizeStrictly(RandomHelper.generateRandomString()));
        AccountPasswordVo accountPasswordVo = AccountPasswordVo.builder()
                .accountId(account.getAccountId())
                .autoGenerated(Boolean.FALSE)
                .clearText(password)
                .build();
        accountPasswordService.createPassword(accountPasswordVo);
    }

    private void initializeUsername(Account account) {
        String username = getUsernameFromEmail(account);
        InitializeUsernameVo initializeUsernameVo = new InitializeUsernameVo();
        initializeUsernameVo.setUsername(username);
        initializeUsernameVo.setRelatedObjectId(account.getAccountId());
        initializeUsernameVo.setRelatedObjectType(UsernameRelatedObjectType.ACCOUNT);
        initializeUsernameVo.setAppendRandomStrOnCollision(Boolean.TRUE);
        usernameService.assignUsername(initializeUsernameVo);
    }

    private void initializeTeam(Account account) {
        String username = getUsernameFromEmail(account);
        TeamInitializeVo teamInitializeVo = new TeamInitializeVo();
        teamInitializeVo.setOwnerId(account.getAccountId());
        teamInitializeVo.setTitle(username);
        teamInitializeVo.setHandle(TEAM_HANDLE_PREFIX + username);
        teamInitializeVo.setVisibility(TeamVisibilityType.HIDDEN_LISTED);
        teamInitializeVo.setJoinType(TeamJoinType.WITH_REQUEST);
        teamInitializeVo.setAppendRandomStrOnCollision(Boolean.TRUE);
        teamInitializeService.initializeTeam(teamInitializeVo);
    }

    private void sendMailConfirmationMail(Account account, AccountInitializeVo accountInitializeVo) {
        Optional.of(accountInitializeVo)
                .map(AccountInitializeVo::getEmailConfirmed)
                .filter(Boolean.FALSE::equals)
                .ifPresent(bool -> {
                    LocaleType localeType = Optional.of(accountInitializeVo)
                            .map(AccountInitializeVo::getPreferredLocale)
                            .orElse(LocaleType.EN);
                    accountMailConfirmationService.sendConfirmEmailMail(account.getAccountId(), localeType);
                });
    }

    private String getUsernameFromEmail(Account account) {
        return Optional.of(account)
                .map(Account::getEmail)
                .map(email -> email.split("@"))
                .map(strings -> strings[0])
                .orElseThrow(BusinessException::new);
    }
}
